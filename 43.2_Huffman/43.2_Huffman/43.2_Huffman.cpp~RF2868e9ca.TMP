#include <iostream>
#include <queue>
#include <unordered_map>
#include <vector>
#include <cmath>
#include <fstream>

using namespace std;

// Структура для узла дерева Хаффмана
struct HuffmanNode {
    char character;
    int frequency;
    HuffmanNode* left;
    HuffmanNode* right;

    HuffmanNode(char ch, int freq) : character(ch), frequency(freq), left(nullptr), right(nullptr) {}
};

// Компаратор для приоритетной очереди
struct CompareNode {
    bool operator()(HuffmanNode* left, HuffmanNode* right) {
        return left->frequency > right->frequency;
    }
};

// Функция для построения дерева Хаффмана с использованием динамического программирования
unordered_map<char, int> buildHuffmanTreeDP(const unordered_map<char, int>& frequencies) {
    priority_queue<HuffmanNode*, vector<HuffmanNode*>, CompareNode> minHeap;

    // Добавляем все символы в очередь
    for (const auto& pair : frequencies) {
        minHeap.push(new HuffmanNode(pair.first, pair.second));
    }

    // Таблица для хранения длины кодов каждого символа
    unordered_map<char, int> codeLengths;
    for (const auto& pair : frequencies) {
        codeLengths[pair.first] = 0;  // Инициализация длиной 0
    }

    // Построение дерева и подсчет глубины (длины кодов) символов
    while (minHeap.size() > 1) {
        HuffmanNode* left = minHeap.top(); minHeap.pop();
        HuffmanNode* right = minHeap.top(); minHeap.pop();

        // Обновляем длину кодов для каждого символа из левого и правого поддерева
        if (left->character) codeLengths[left->character]++;
        if (right->character) codeLengths[right->character]++;

        // Для всех листьев ниже объединенного узла увеличиваем длину кода
        for (auto& pair : codeLengths) {
            if (pair.first == left->character || pair.first == right->character) {
                pair.second++;
            }
        }

        // Создаем новый узел и добавляем его в очередь
        HuffmanNode* newNode = new HuffmanNode('\0', left->frequency + right->frequency);
        newNode->left = left;
        newNode->right = right;

        minHeap.push(newNode);
    }

    return codeLengths;
}

// Основная функция для вычисления общего количества байт
int calculateBytes(const vector<int> array) {
    unordered_map<char, int> frequencies;


    // Строим дерево Хаффмана и получаем длину кодов символов с помощью DP
    unordered_map<char, int> codeLengths = buildHuffmanTreeDP(frequencies);

    // Подсчитываем общее количество битов
    int totalBits = 0;
    for (const auto& pair : frequencies) {
        char character = pair.first;
        int freq = pair.second;
        totalBits += freq * codeLengths[character];
    }

    // Переводим в байты, округляя вверх
    int totalBytes = (totalBits + 7) / 8; // +7 для округления вверх при делении на 8
    return totalBytes;
}

int main() {
    setlocale(LC_ALL, "rus");
    ifstream in("huffman.in");
    ofstream out("huffman.out");
    string text;
    int n;
    in >> n;
    vector <int> array(n);
    cout << "Введите строку для кодирования: ";
    for (int i = 0; i < n; i++) {
        in >> array[i];
    }

    int bytesNeeded = calculateBytes(array);
    cout << "Количество байт, необходимых для кодирования: " << bytesNeeded << endl;

    return 0;
}
